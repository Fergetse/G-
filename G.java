/* Generated By:JavaCC: Do not edit this line. G.java */
import java.util.HashMap;
import java.util.ArrayList;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

public class G implements GConstants {
    public static int cont = 0, cont1 = 0, tempC = 0;
    public static HashMap<String, Data> table = new HashMap<String, Data>();

  public static void main(String[] args) {
    try {
      String input = obtenerEntradaDesdeConsola();
      InputStream newInputStream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8));
      G parser = new G(newInputStream);

      //primer barrido
      parser.start(true);
      System.out.println(table);
      System.out.println("******* PRIMER BARRIDO TERMINADO ******* \n\n\n");

      // Reinicia el analizador léxico para el segundo barrido
      // Llamada a un método para obtener la entrada desde la consola
      newInputStream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8));
      parser.ReInit(newInputStream);

      // Segundo barrido

            //Generación de código
            printCode(createVars());
            cont1 = 0;
            tempC = 0;
            //printCode(createStatements());
            //printCode(createPrintable());

      parser.start(false);


      System.out.println("******* SEGUNDO BARRIDO TERMINADO ******* \n\n\n");

      System.out.println("\n\n\n\nAn\u00c3\u00a1lisis exitoso");

    } catch (ParseException e) {
      e.printStackTrace();
    }
  }

  //todo Métodos de tabla de valores////////

  public static boolean exist(String id){
    if(table.containsKey(id))
        return true;
    return false;
}

  public static void insertId(String id, String type, String value){
    if(exist(id)){
      System.out.println("Error: Variable repetida "+id);
      return;
    }
    table.put(id, new Data(id, type, value));
  }

  public static Data getId(String id){
    if(!exist(id)){
      return null;
    }
    return table.get(id);
  }

  //todo /////////////////////////////////////

  ////////////////////////////////

  public static String obtenerEntradaDesdeConsola() {
    StringBuilder sb = new StringBuilder();
    Scanner scanner = new Scanner(System.in);
    while (scanner.hasNextLine()) {
        sb.append(scanner.nextLine());
        sb.append(System.lineSeparator());
    }
    return sb.toString();
  }

  ////////////////////////////////
  public static String getnmonic(String id){
    String nm = "";
    switch (id) {
        case "be":
            nm = "jl";
            break;
        case "beq":
            nm = "jle";
            break;
        case "geq":
            nm = "jge";
            break;
        case "eq":
            nm = "je";
            break;
        case "ge":
            nm = "jg";
            break;
        case "neq":
            nm = "jne";
            break;
            //Contrarios
        case "!be":
            nm = "jge";
            break;
        case "!beq":
            nm = "jg";
            break;
        case "!geq":
            nm = "jl";
            break;
        case "!eq":
            nm = "jne";
            break;
        case "!ge":
            nm = "jle";
            break;
        case "!neq":
            nm = "je";
            break;
        default:
            nm = "def";
            break;
    }
    return nm;
}

///todo Méotodos para la generación de código

public static String printValue(String id){
  String ret = setValues("ax", id)+"\n";
  ret += ("call print\n");
  ret += printSpace();
  return ret;
}

public static String printWord(String word, boolean var){
  String id = word;
  String ret = "";

  if(!var){
    id = generateMSG();
    if(!exist(id))
      insertId(id,"word", word);
    else{
      ret += ("mov ax, @data\n"+
      "mov ds, ax\n"+
      "mov ah, 09h\n"+
      "mov dx, offset "+id+"\n"+
      "int 21h\n");
      ret += printSpace();
      return ret;
    }
  }else{
    ret += ("mov ax, @data\n"+
    "mov ds, ax\n"+
    "mov ah, 09h\n"+
    "mov dx, offset "+id+"\n"+
    "int 21h\n");
    ret += printSpace();
    return ret;
  }
  ret += printSpace();
  return ret;
}

public static String printSpace(){
  String ret = ("mov ah, 02h\n"+
          "mov dl, 0ah\n"+
          "int 21h\n"+
          "mov dl, 0dh\n"+
          "int 21h\n"+
          "mov ah, 0\n");
  return ret;
}

public static String createVars(){
  Data value = null;
  String ret = "";
  for (String key: table.keySet()) {
    value = table.get(key);
    if(value.type.equals("word")){
      ret += value.id + " dw " + "\"" + value.value + " $\"\n";
    }else{
      ret += value.id + " dw " + value.value + "\n";
    }
  } //another option .model small
  return (".model tiny\n"+
          ".stack 100h\n"+
          "jmp start\n .data\n"+ret+"\nstart:\n.code\n");
}

public static String createTempVar(){
  return ("temp" + (tempC++));
}

//todo // generación de estructuras//////////////////////////////////// (1)
public static String generateLoop(String label, String id, String limit, String condition){
  String nm = getnmonic(condition);
  String ret = ("cmp "+id+", "+limit+"\n");
  ret += (nm+" "+label+"\n");
  ret += setValues(id, "0")+"\n";
  return ret;
}

public static String generateIf(String id, String[] info, String label){
  //String v1 = opVar();


  String nm = getnmonic("!"+info[0]);
  String ret = ("cmp "+id+", "+info[1]+"\n");
  ret += (nm + " " + label);
  return ret;
}

public static String generateOp(String values){
  String res = "";
  return res;
}
//todo //////////////////////////////////////////////////////////////// (1)


  public static void printCode(String code){
    System.out.println(code);
  }

  public static String[] getValues(String complete){
    String[] values = {"", ""};
    for(int i = 0; complete.charAt(i) != ' '; i++){
        values[0] += complete.charAt(i)+"";
    }
    for(int i = complete.length()-1; complete.charAt(i) != ' '; i--){
        values[1] += complete.charAt(i)+"";
    }

    StringBuilder val = new StringBuilder(values[1]);
    values[1] = String.valueOf(val.reverse());
    return values;
  }

  public static String createVar(String name, String type, String value){
    /*if(value.contains("add")){
        return makeAdd(value, name);
    }*/
    return (name + " " + type + " " + value);
  }

  public static String opVar(String name, String value){
    if(value.contains("add")){
        return makeAdd(value, name);
    }else if(value.contains("sub")){
      return makeSub(value, name);
    }else if(value.contains("mul")){
      return makeMul(value, name);
    }else if(value.contains("div")){
      return makeDiv(value, name);
    }else if(value.contains("mod")){
      return makeMod(value, name);
    }

    return setValuesVar(name, value);
  }

  public static String generateLabel(){
    return ("label" + (cont++));
  }

  public static String generateMSG(){
    return ("msglabel_msg" + (cont1++));
  }

  public static String makeAdd(String v, String var) {
    String values[] = getValues(v);
    String ret = "", v1 = values[0], v2 = values[1];

    //String temp = generateTemp();
    String temp = "ax";
    //ret += createVar(temp, "dw", "0")+"\n";
    //ret += createVar(var, "dw", "0")+"\n";

    String val = setValues(temp, v1);
    ret += val + "\n";
    ret += "add " + temp + ", " + v2;
    ret += "\n"+setValues(var, temp);
    return ret;
  }

  public static String makeMul(String v, String var){
    String values[] = getValues(v);
    String ret = "", v1 = values[0], v2 = values[1];

    String temp = "ax";

    String val = setValues(temp, v1);
    ret += val + "\n";
    ret += "imul " + v2;
    ret += "\n"+setValues(var, temp);

    return ret;
  }

  public static String makeDiv(String v, String var){
    String values[] = getValues(v);
    String ret = "", v1 = values[0], v2 = values[1];
    String temp = "ax";

    String val = setValues(temp, v1);
    ret += val + "\n";
    val = setValues("dx", "0");
    ret += val + "\n";
    ret += "idiv " + v2 + "\n";
    ret += setValues(var, temp);
    return ret;
  }

  public static String makeMod(String v, String var){
    String values[] = getValues(v);
    String ret = "", v1 = values[0], v2 = values[1];
    String temp = "ax";

    String val = setValues(temp, v1);
    ret += val + "\n";
    val = setValues("dx", "0");
    ret += val + "\n";
    ret += "idiv " + v2 + "\n";
    ret += setValues(var, "dx");
    return ret;
  }

  public static String makeSub(String v, String var) {
    String values[] = getValues(v);
    String ret = "", v1 = values[0], v2 = values[1];

    String temp = "ax";

    String val = setValues(temp, v1);
    ret += val + "\n";
    ret += "sub " + temp + ", " + v2;
    ret += "\n"+setValues(var, temp);
    return ret;
  }

  public static String setValues(String v1, String v2){
    return ("mov " + v1 + ", " + v2);
  }

  public static String setValuesVar(String v1, String v2){
    String ret = "";
    String val = setValues("ax", v2);
    ret += val + "\n";
    ret += "add " + "ax" + ", " + 0;
    ret += "\n"+setValues(v1, "ax");
    return ret;
  }

    public static String printValueBin(){
        return ("print proc\n"+
                "pusha\n"+
                "mov bx, ax\n"+
                "mov cx, 8\n"+

                "print_bit:\n"+
                    "mov ah, 02h\n"+
                    "mov dl, '0'\n"+
                    "test bx, 10000000b\n"+
                    "jz zero\n"+
                    "mov dl, '1'\n"+

                "zero:\n"+
                    "int 21h\n"+
                    "shl bx, 1\n"+
                    "loop print_bit\n"+
                "mov ah, 02h\n"+
                "mov dl, 'b'\n"+
                "int 21h\n"+
                "popa\n"+
                "ret\n"+
            "endp\n"
        );
    }

    public static String printValueDecim(){
        return (
            "print proc\n"+
            "cmp ax, 0\n"+
            "jne print_ax_r\n"+
                "push ax\n"+
                "mov al, '0'\n"+
                "mov ah, 0eh\n"+
                "int 10h\n"+
                "pop ax\n"+
                "ret \n"+
           "print_ax_r:\n"+
                "pusha\n"+
                "mov dx, 0\n"+
                "cmp ax, 0\n"+
                "je pn_done\n"+
                "mov bx,10\n"+
                "div bx\n"+
                "call print_ax_r\n"+
                "mov ax, dx\n"+
                "add al, 30h\n"+
                "mov ah, 0eh\n"+
                "int 10h\n"+
                "jmp pn_done\n"+
            "pn_done:\n"+
                "popa\n"+
                "ret\n"+
            "endp\n"
        );
    }

//SPECIAL_TOKEN : { < COMMENT: "comment" (~[""])* "end" > }
  static final public void start(boolean inicial) throws ParseException, ParseException {
    Program(inicial);
    jj_consume_token(0);
  }

  static final public void Program(boolean inicial) throws ParseException {
    jj_consume_token(START);

    Declarations(inicial);

    Statements(inicial);
    jj_consume_token(END);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      jj_consume_token(DOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIN:
      case DEC:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEC:
          jj_consume_token(DEC);
        {
          if(!inicial){
            System.out.println("\nret\n");
            printCode(printValueDecim());
          }
        }
          break;
        case BIN:
          jj_consume_token(BIN);
        {
          if(!inicial){
            System.out.println("\nret\n");
            printCode(printValueBin());
          }
        }
          break;
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
  }

  static final public void Declarations(boolean inicial) throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
      case WORD:
      case BYTE:
      case DECIMAL:
      case ARRAY:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_1;
      }
      Declaration(inicial);
    }
  }

  static final public void Declaration(boolean inicial) throws ParseException {
   String name = "", type = "", value = "";
    type = Type(inicial);
    name = Variable(inicial);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SET:
      jj_consume_token(SET);
      value = Expression(inicial, true/* true if its a declaration*/);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    jj_consume_token(DOT);
      if(inicial){
        insertId(name, type, value);
        {if (true) return;}
      }
        //Data val = getId(name);
       // printCode(createVar(val.id, val.type, val.value));

  }

  static final public String Type(boolean inicial) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      jj_consume_token(INT);
      break;
    case WORD:
      jj_consume_token(WORD);
      break;
    case BYTE:
      jj_consume_token(BYTE);
      break;
    case DECIMAL:
      jj_consume_token(DECIMAL);
      break;
    case ARRAY:
      jj_consume_token(ARRAY);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

  static final public String Variable(boolean inicial) throws ParseException {
    jj_consume_token(IDENTIFIER);
        {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

  static final public String Expression(boolean inicial, boolean isDeclaration) throws ParseException {
   String valor = "", val = "";
    valor = Term(inicial, isDeclaration);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
      case SUB:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_2;
      }
      val = AddOp(inicial);
        valor += val;
      val = Term(inicial, isDeclaration);
        valor += val;
    }
        {if (true) return valor;}
    throw new Error("Missing return statement in function");
  }

  static final public String Term(boolean inicial, boolean isDeclaration) throws ParseException {
   String valor = "", val = "";
    valor = Factor(inicial, isDeclaration);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MUL:
      case DIV:
      case MOD:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_3;
      }
      val = MulOp(inicial);
        valor += val;
      val = Factor(inicial, isDeclaration);
        valor += val;
    }
        {if (true) return valor;}
    throw new Error("Missing return statement in function");
  }

  static final public String Factor(boolean inicial, boolean isDeclaration) throws ParseException {
   String valor = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      valor = Variable(inicial);
      break;
    case INTEGER:
    case STRING:
    case CHAR:
    case FLOAT:
      valor = Constant(inicial, isDeclaration);

      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return valor;}
    throw new Error("Missing return statement in function");
  }

  static final public String Constant(boolean inicial, boolean isDeclaration) throws ParseException {
   String valor = "", var = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case CHAR:
    case FLOAT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        valor = Integer(inicial);
        break;
      case CHAR:
        valor = Character(inicial);
        break;
      case FLOAT:
        valor = Float(inicial);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      //si es el primer barrido, no es declaración y el valor es constante se crea una variable
        if(inicial && !isDeclaration)
          insertId(createTempVar(), "dw", valor);

        if(!inicial && !isDeclaration){
          var = createTempVar();
          if(exist(var)){
            {if (true) return var;}
          }
        }
        {if (true) return valor;}
      break;
    case STRING:
      valor = Word(inicial);
      {if (true) return valor;}
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String Integer(boolean inicial) throws ParseException {
   String valor = "";
    jj_consume_token(INTEGER);
        {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

  static final public String Word(boolean inicial) throws ParseException {
   String valor = "";
    jj_consume_token(STRING);
        {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

  static final public String Character(boolean inicial) throws ParseException {
   String valor = "";
    jj_consume_token(CHAR);
        {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

  static final public String Float(boolean inicial) throws ParseException {
   String valor = "";
    jj_consume_token(FLOAT);
        {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

  /*void Array(boolean inicial) :
  {}
  {
    <ARRAY_START> (Constant(inicial) ("," Constant(inicial))*)? <ARRAY_END>
  }*/
  static final public String AddOp(boolean inicial) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ADD:
      jj_consume_token(ADD);
      break;
    case SUB:
      jj_consume_token(SUB);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return (" "+token.image+" ");}
    throw new Error("Missing return statement in function");
  }

  static final public String MulOp(boolean inicial) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MUL:
      jj_consume_token(MUL);
      break;
    case DIV:
      jj_consume_token(DIV);
      break;
    case MOD:
      jj_consume_token(MOD);
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return (" "+token.image+" ");}
    throw new Error("Missing return statement in function");
  }

  static final public void Statements(boolean inicial) throws ParseException {
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case REPEAT:
      case SHOW:
      case SHOWW:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_4;
      }
      Statement(inicial);
    }
  }

  static final public void Statement(boolean inicial) throws ParseException {
   String value = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      Assignment(inicial);
      break;
    case IF:
      Conditional(inicial);
      break;
    case REPEAT:
      Loop(inicial);
      break;
    case SHOW:
      jj_consume_token(SHOW);
      jj_consume_token(DOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        value = Variable(inicial);
        if(!inicial){
          if(!exist(value)){
            System.out.println("Error, la variable no existe: " + value);
          }else{
            printCode(printValue(value));
          }
        }
        break;
      case INTEGER:
      case STRING:
      case CHAR:
      case FLOAT:
        value = Constant(inicial, false);
        if(!inicial){
          printCode(printValue(value));
        }
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(DOT);

      break;
    case SHOWW:
      jj_consume_token(SHOWW);
      jj_consume_token(DOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        value = Variable(inicial);
      if(!inicial){
        if(!exist(value)){
          System.out.println("Error, la variable no existe: " + value);
        }else{
          printCode(printWord(value, true));
        }
      }
        break;
      case INTEGER:
      case STRING:
      case CHAR:
      case FLOAT:
        value = Constant(inicial, false);
      if(inicial){
        printCode(printWord(value, false));
      }else{
        printCode(printWord(value, false));
      }
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(DOT);

      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Assignment(boolean inicial) throws ParseException {
   String name ="", value = "";
    name = Variable(inicial);
    jj_consume_token(SET);
    value = Expression(inicial, false);
    jj_consume_token(DOT);
        if(!inicial){
          if(!exist(name)){
            System.out.println("Error, la id no est\u00c3\u00a1 declarada: " + name);
            {if (true) return;}
          }

          printCode(opVar(name, value));
      }
  }

  static final public void Conditional(boolean inicial) throws ParseException {
   String label = "", id = ""; String[] info = {};
    jj_consume_token(IF);
      if(!inicial)
        label = generateLabel();
    id = Expression(inicial, true);
    info = Condition(inicial, true);
    jj_consume_token(DOT);
    jj_consume_token(DOT);
      if(!inicial)
        printCode(generateIf(id, info, label));
      else{
        //! /////////////////// if con múltiples operaciones
      }
    Statements(inicial);
    jj_consume_token(DOT);
    jj_consume_token(DOT);
      printCode(label+":\n");
  }

  static final public String[] Condition(boolean inicial, boolean isDeclaration) throws ParseException {
   String id = "", valueC = "";
    valueC = CompareOp(inicial);
    id = Expression(inicial, isDeclaration);
      {if (true) return (new String[]{valueC, id});}
    throw new Error("Missing return statement in function");
  }

  static final public String CompareOp(boolean inicial) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
      jj_consume_token(EQ);
      break;
    case NEQ:
      jj_consume_token(NEQ);
      break;
    case BEQ:
      jj_consume_token(BEQ);
      break;
    case GEQ:
      jj_consume_token(GEQ);
      break;
    case BE:
      jj_consume_token(BE);
      break;
    case GE:
      jj_consume_token(GE);
      break;
    case AND:
      jj_consume_token(AND);
      break;
    case OR:
      jj_consume_token(OR);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

  static final public void Loop(boolean inicial) throws ParseException {
   String id = "", value = "", type = "", limit = "", label = "";
    jj_consume_token(REPEAT);
      if(!inicial){
        label = generateLabel();
        printCode(label+":\n");
      }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      jj_consume_token(IF);
      Expression(inicial, true);
      Condition(inicial, true);
      jj_consume_token(DOT);
      jj_consume_token(DOT);
      Statements(inicial);
      jj_consume_token(DOT);
      jj_consume_token(DOT);
      break;
    case INT:
      jj_consume_token(INT);
      type = token.image;
      jj_consume_token(IDENTIFIER);
      id = token.image;
      jj_consume_token(SET);
      jj_consume_token(INTEGER);
      value = token.image;
      if(inicial){
        insertId(id, type, value);
      }
      jj_consume_token(TO);
      jj_consume_token(INTEGER);
      limit = token.image;
      jj_consume_token(DOT);
      jj_consume_token(DOT);
      Statements(inicial);
      jj_consume_token(DOT);
      jj_consume_token(DOT);
      //establecemos la repetición condicional
      if(!inicial)
        printCode(generateLoop(label, id, limit, "be"));
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public GTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[19];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xc000,0xc000,0x800,0x1f00000,0x100,0x1f00000,0x6000000,0x38000000,0x0,0x0,0x0,0x6000000,0x38000000,0xc0600,0x0,0x0,0xc0600,0xc0030000,0x100200,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f0,0x1a0,0x1e0,0x0,0x0,0x10,0x1f0,0x1f0,0x10,0xf,0x0,};
   }

  /** Constructor with InputStream. */
  public G(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public G(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new GTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public G(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new GTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public G(GTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(GTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List jj_expentries = new java.util.ArrayList();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[46];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 19; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 46; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}

//! Clase para los ID declaradas///////
class Data{
  String id;
  String type; //int, decimal, byte ...
  String value;

  Data(String id, String type, String value){
    this.id = id;
    this.type = type;
    if(value.equals(""))
      this.value = "?";
    else
      this.value = value;
  }

  @Override
  public String toString(){
    return ("[ id: "+id + ", type: "+type + ", value: " + value +" ]\n");
  }
}
